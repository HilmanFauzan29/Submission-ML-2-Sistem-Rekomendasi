# -*- coding: utf-8 -*-
"""SistemRekomendasiSpotify.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FV_7I-cJXSsUX2krWDhnaydjmfz-EWdz

## Proyek Sistem Rekomendasi Musik Spotify
- Nama  : Hilman Fauzan
- Email : hilmanfauzan462@gmail.com

## Import Library
"""

import pandas as pd
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.preprocessing import StandardScaler
from sklearn.metrics.pairwise import cosine_similarity
from scipy.sparse import hstack
import sys
import matplotlib.pyplot as plt
import seaborn as sns

"""Dalam submission ini, library yang dipakai yaitu:
- pandas dan numpy sebagai fondasi untuk manipulasi data tabular dan komputasi numerik.
- sklearn, TfidfVectorizer digunakan untuk mengubah data tekstual seperti nama lagu dan genre menjadi format numerik.
- StandardScaler digunakan untuk menskalakan fitur numerik audio agar seragam.
- cosine_similarity digunakan untuk menghitung kemiripan antar lagu berdasarkan fitur-fitur tersebut. Hal ini merupakan sebuah inti dari sistem Content-based.
- scipy.sparse.hstack digunakan untuk menggabungkan representasi fitur tekstual yang efisien (sparse) dengan fitur numerik.
- matplotlib.pyplot dan seaborn adalah alat visualisasi data yang penting untuk mengeksplorasi dan memahami karakteristik dataset.
- sys menyediakan fungsi interaksi sistem dasar seperti menangani keluar dari program saat error.

## Data Understanding
"""

# Data Load
file_path_high_pop = "high_popularity_spotify_data.csv"
file_path_low_pop = "low_popularity_spotify_data.csv"

df_high_pop = pd.read_csv(file_path_high_pop)
df_low_pop = pd.read_csv(file_path_low_pop)

if list(df_high_pop.columns) != list(df_low_pop.columns):
    print("\nNama kolom diantara kedua file tidak sama percis.")

"""Dataset diambil dari 2 file yaitu high_popularity_spotify_data.csv dan low_popularity_spotify_data.csv. Kode paling bawah digunakan untuk mengecek kesamaan kolom diantara 2 file, dan kedua file tersebut memiliki nama kolom yang tidak percis atau urutannya berbeda.

**Pengecekan Dataset High Popularity**
"""

print("5 Data awal dari high_popularity")
df_high_pop.head()

"""Kode diatas menampilkan 5 baris teratas dari data set high_popularity_spotify_data.csv"""

print("Tipe Data dari high_popularity")
df_high_pop.info()

"""Dataset memiliki 29 kolom atau fitur yang bertipe float64 sebanyak 9 kolom, integer 5 kolom, dan object sebanyak 15 kolom."""

# Statistik
print("Deskripsi Statitik Data dari high_popularity")
df_high_pop.describe()

"""Kode di atas menampilkan informasi deskripsi statistik dari dataset high_popularity_spotify_data.csv yang terdiri dari jumlah baris, rata-rata, standar deviasi, jumlah minimal, Quartal 1, Quartal 2, Quartal 3, dan jumlah maksimal dari setiap kolom."""

print("Jumlah missing values per kolom pada Data High Popularity:")
print(df_high_pop.isnull().sum())

"""Dalam pengecekan missing value dari dataset high_popularity_spotify_data.csv, ditemukan bahwa hanya terdapat 1 missing value pada kolom track_album_name saja, selain itu aman."""

print("\nJumlah baris duplikat pada Data High Popularity:")
num_duplicates = df_high_pop.duplicated().sum()
print(num_duplicates)

"""Dalam pengecekan data duplikat dari dataset high_popularity_spotify_data.csv, tidak ada data atau baris yang duplikat.

**Pengecekan Dataset Low Popularity**
"""

print("5 Data awal dari low_popularity")
df_low_pop.head()

"""Menampilkan 5 data teratas dari dataset low_popularity_spotify_data.csv"""

print("Tipe Data dari low_popularity")
df_low_pop.info()

"""Dataset memiliki 29 kolom atau fitur"""

print("Deskripsi Statistik Data dari low_popularity")
df_low_pop.describe()

"""Kode di atas menampilkan informasi deskripsi statistik dari dataset low_popularity_spotify_data.csv yang terdiri dari jumlah baris, rata-rata, standar deviasi, jumlah minimal, Quartal 1, Quartal 2, Quartal 3, dan jumlah maksimal dari setiap kolom."""

print("Jumlah missing values per kolom pada Data Low Popularity:")
print(df_low_pop.isnull().sum())

"""Dalam pengecekan dataset dari missing value, ditemukan 1 dalam kolom time_signature, 1 dalam kolom speechiness, 1 dalam kolom danceability, 1 dalam kolom duration_ms, 1 dalam kolom energy, 1 dalam kolom id, 1 dalam kolom track_href, 1 dalam kolom mode, 1 dalam kolom uri, 1 dalam kolom type, 1 dalam kolom analysis_url, 1 dalam kolom instrumentalness, 1 dalam kolom valenve, 1 dalam kolom key, 1 dalam kolom tempo, 1 dalam kolom loudnesss, 1 dalam kolom acousticness, dan 1 dalam kolom liveness."""

print("\nJumlah baris duplikat pada Data Low Popularity:")
num_duplicates = df_low_pop.duplicated().sum()
print(num_duplicates)

"""Dataset low_popularity_spotify_data.csv tidak terdapat data atau bariss yang duplikat.

## Data Preparation

Penanganan Missing Value pada High_Popularity
"""

# Daftar kolom yang memiliki missing value hanya di track_album_name
text_cols_high_pop = ['track_album_name']
# Filter kolom yang benar-benar ada dan bertipe objek/string
text_cols_high_pop_exist = [
    col for col in text_cols_high_pop
    if col in df_high_pop.columns and df_high_pop[col].dtype == 'object'
]

if text_cols_high_pop_exist:
    print(f"Mengisi missing values kolom teks/kategorikal ({len(text_cols_high_pop_exist)} kolom) pada df_high_pop: {text_cols_high_pop_exist}")
    for col in text_cols_high_pop_exist:
        df_high_pop[col] = df_high_pop[col].fillna('')
        df_high_pop[col] = df_high_pop[col].astype(str)

print("Penanganan missing values pada df_high_pop selesai.")
print("Jumlah missing values pada Data High Popularity setelah penanganan:")
print(df_high_pop.isnull().sum().sum(), "total missing values.")

"""Penanganan missing value dilakukan pada kolom track_album_name pada data set high_popularity_spotify_data.csv

**Penanganan Missing Value pada Low_Popularity**
"""

# Daftar kolom teks/kategorikal yang memiliki missing value di df_low_pop yaitu 'track_href', 'uri', 'type', 'analysis_url', 'id'
text_id_cols_low_pop = ['track_href', 'uri', 'type', 'analysis_url', 'id']
# Filter kolom yang benar-benar ada dan bertipe objek/string
text_id_cols_low_pop_exist = [
    col for col in text_id_cols_low_pop
    if col in df_low_pop.columns and df_low_pop[col].dtype == 'object'
]

if text_id_cols_low_pop_exist:
    print(f"Mengisi missing values kolom teks/ID ({len(text_id_cols_low_pop_exist)} kolom) pada df_low_pop: {text_id_cols_low_pop_exist}")
    for col in text_id_cols_low_pop_exist:
        df_low_pop[col] = df_low_pop[col].fillna('')
        df_low_pop[col] = df_low_pop[col].astype(str)


# Daftar kolom numerik yang memiliki missing value di df_low_pop
numeric_cols_low_pop = [
    'time_signature', 'speechiness', 'danceability', 'duration_ms',
    'energy', 'mode', 'instrumentalness', 'valence', 'key', 'tempo',
    'loudness', 'acousticness', 'liveness'
]
# Filter kolom numerik yang benar-benar ada dan bertipe numerik
numeric_cols_low_pop_exist = [
     col for col in numeric_cols_low_pop
     if col in df_low_pop.columns and pd.api.types.is_numeric_dtype(df_low_pop[col])
]


if numeric_cols_low_pop_exist:
    print(f"Mengisi missing values kolom numerik ({len(numeric_cols_low_pop_exist)} kolom) pada df_low_pop: {numeric_cols_low_pop_exist}")
    for col in numeric_cols_low_pop_exist:
        # Pastikan kolom bertipe numerik sebelum menghitung median
        if pd.api.types.is_numeric_dtype(df_low_pop[col]):
             median_val = df_low_pop[col].median()
             df_low_pop[col] = df_low_pop[col].fillna(median_val)
        else:
             print(f"Peringatan (Low Pop Handling): Kolom '{col}' bukan tipe numerik, tidak diisi NaN dengan median.")


print("Penanganan missing values pada df_low_pop selesai.")
print("Jumlah missing values pada Data Low Popularity setelah penanganan:")
print(df_low_pop.isnull().sum().sum(), "total missing values.")

"""Penanganan missing value pada low_popularity dilakukan pada kolom-kolom yang memiliki missing value.

Penggabungan Data Set
"""

df_combined = pd.concat([df_high_pop, df_low_pop], ignore_index=True, sort=False)

print(f"Jumlah baris total setelah digabung: {df_combined.shape[0]}")
print(f"Jumlah kolom setelah digabung: {df_combined.shape[1]}")

"""kedua dataset digabung menjadi satu dengan fungsi df_combined dan memiliki 29 kolom dan 4831 baris."""

# Gunakan df_combined sebagai variabel utama 'df'
df = df_combined.copy()

"""Menggunakan fungsi df sebagai variabel utama.

Pengecekan kembali dataset gabungan
"""

print("\nTampilan 5 baris pertama DataFrame gabungan:")
print(df.head())

"""Menampilkan 5 baris pertama dari dataset gabungan."""

df.info()

"""Dataset memiliki 29 kolom atau fitur"""

print("Jumlah missing values per kolom pada DataFrame gabungan:")
print(df.isnull().sum())

"""Dataset gabungan tidak terdapat missing value."""

print("\nJumlah baris duplikat pada Data Gabungan:")
num_duplicates = df.duplicated().sum()
print(num_duplicates)

"""Dataset gabungan memiliki 43 baris duplikat yang harus ditangani."""

if num_duplicates > 0:
  print(f"Menghapus {num_duplicates} baris duplikat...")
df = df.drop_duplicates().reset_index(drop=True)
print(f"Jumlah baris setelah menghapus duplikat: {df.shape[0]}")

"""Data duplikat pada dataset gabungan ditangani dengan cara dihapus dan sekarang dataset gabungan memiliki 4.788 baris."""

print("\nJumlah baris duplikat pada Data Gabungan:")
num_duplicates = df.duplicated().sum()
print(num_duplicates)

"""Pengecekan kembali setelah ditangani dan tidak terdapat data duplikat."""

# Statistik deskriptif untuk kolom numerik pada DataFrame gabungan
print("\nStatistik deskriptif untuk kolom numerik pada DataFrame gabungan:")
numeric_cols_for_describe = df.select_dtypes(include=np.number).columns.tolist()
print(df[numeric_cols_for_describe].describe())

"""Kode di atas menampilkan informasi deskripsi statistik dari dataset gabungan yang terdiri dari jumlah baris, rata-rata, standar deviasi, jumlah minimal, Quartal 1, Quartal 2, Quartal 3, dan jumlah maksimal dari setiap kolom."""

# Melihat nilai unik pada kolom kategorikal penting
categorical_cols_to_check = ['playlist_genre', 'playlist_subgenre', 'track_artist']

"""Kode di atas digunakan untuk melihat nilai unik pada kolom kategorikal penting."""

print("\nPengecekan Kolom Kategorikal/Tekstual Penting pada DataFrame gabungan:")
for col in categorical_cols_to_check:
    if col in df.columns:
        print(f"\nJumlah nilai unik pada kolom '{col}':")
        print(df[col].nunique())
        print(f"Contoh '{col}' (10 nilai pertama):")
        print(df[col].astype(str).fillna('').unique()[:10])
    else:
        print(f"\nPeringatan: Kolom '{col}' tidak ditemukan dalam DataFrame gabungan.")

"""Hasil pengecekan data unik pada kolom kategorikal dimana terdapat 35 pada kolom playlist_genre, 84 pada kolom playlist_subgenre, dan 3.390 pada kolom track_artist.

**Visualisasi Data Gabungan**
"""

# Visualisasi Distribusi Fitur Numerik (Fitur Audio dan Popularitas)
numeric_cols_for_viz = [
    'danceability', 'energy', 'valence', 'tempo', 'loudness',
    'acousticness', 'instrumentalness', 'liveness', 'speechiness',
    'duration_ms', 'track_popularity'
]
numeric_cols_for_viz_exist = [col for col in numeric_cols_for_viz if col in df.columns and pd.api.types.is_numeric_dtype(df[col])]

if numeric_cols_for_viz_exist:
    print("Membuat histogram untuk fitur numerik...")
    n_cols = 3
    n_rows = (len(numeric_cols_for_viz_exist) + n_cols - 1) // n_cols
    fig, axes = plt.subplots(n_rows, n_cols, figsize=(n_cols * 5, n_rows * 4))
    axes = axes.flatten()

    for i, col in enumerate(numeric_cols_for_viz_exist):
        if not df[col].dropna().empty:
             sns.histplot(df[col].dropna(), bins=30, kde=True, ax=axes[i])
             axes[i].set_title(f'Distribusi {col}')
             axes[i].set_xlabel(col)
             axes[i].set_ylabel('Frekuensi')
        else:
             fig.delaxes(axes[i])

    for j in range(i + 1, len(axes)):
        fig.delaxes(axes[j])

    plt.suptitle('Distribusi Fitur Numerik (DataFrame Gabungan)', y=1.02, ha='center', fontsize=16)
    plt.tight_layout()
    plt.show()

"""Visualisasi di atas merupakan grafik dari distribusi frekuensi pada danceability, energy, valence, tempo, loudness, acousticness, instrumentalness, liveness, speechiness, duration_ms, dan track_popularity."""

# Visualisasi Distribusi Kolom Kategorikal Penting (Genre, Subgenre)
categorical_cols_for_viz = ['playlist_genre', 'playlist_subgenre']
categorical_cols_for_viz_exist = [col for col in categorical_cols_for_viz if col in df.columns]

if categorical_cols_for_viz_exist:
    for col in categorical_cols_for_viz_exist:
        plt.figure(figsize=(12, 6))
        top_categories = df[col].astype(str).value_counts().nlargest(20)
        if not top_categories.empty and top_categories.sum() > 0: # Cek jika ada data non-NaN dan hitungannya > 0
            sns.barplot(x=top_categories.index, y=top_categories.values, palette='viridis')
            plt.title(f'Distribusi Top {len(top_categories)} {col} (DataFrame Gabungan)')
            plt.xlabel(col)
            plt.ylabel('Jumlah Lagu')
            plt.xticks(rotation=45, ha='right')
            plt.tight_layout()
            plt.show()
        else:
             print(f"Tidak ada data valid atau hitungan > 0 untuk membuat plot distribusi '{col}'.")

"""Visualisasi di atas adalah grafik distribusi jumlah lagu pada playlist genre dan playlist subgenre."""

# Visualisasi Distribusi Artis Teratas
if 'track_artist' in df.columns:
    plt.figure(figsize=(12, 6))
    top_artists = df['track_artist'].astype(str).value_counts().nlargest(20)
    if not top_artists.empty and top_artists.sum() > 0:
        sns.barplot(x=top_artists.index, y=top_artists.values, palette='plasma')
        plt.title('Distribusi Top 20 Artis (DataFrame Gabungan)')
        plt.xlabel('Artis')
        plt.ylabel('Jumlah Lagu')
        plt.xticks(rotation=45, ha='right')
        plt.tight_layout()
        plt.show()
    else:
         print("Tidak ada data valid atau hitungan > 0 untuk membuat plot distribusi artis.")

"""Visualisasi di atas adalah grafik 20 artis teratas berdasarkan jumlah lagu."""

# Membuat Kombinasi Fitur Tekstual
print("Membuat fitur tekstual gabungan")

# Menentukan daftar kolom kategorikal/tekstual yang ingin digabungkan
text_categorical_cols = [
    'track_name', 'track_artist', 'track_album_name', 'playlist_name',
    'playlist_genre', 'playlist_subgenre'
]

# Memfilter kolom yang benar-benar ada di dalam DataFrame 'df'
text_categorical_cols_exist = [
    col for col in text_categorical_cols
    if col in df.columns
]

if text_categorical_cols_exist:
    for col in text_categorical_cols_exist:
        df[col] = df[col].astype(str).fillna('')

    # Menggabungkan kolom-kolom teks yang ada menjadi satu kolom baru 'text_features'
    df['text_features'] = df[text_categorical_cols_exist].agg(' '.join, axis=1)
    print("Fitur tekstual gabungan berhasil dibuat.")
else:
    df['text_features'] = ''
    print("Peringatan: Tidak ada kolom tekstual yang relevan ditemukan untuk fitur gabungan.")

"""Blok kode ini bertanggung jawab untuk membuat fitur tekstual gabungan dengan mengumpulkan informasi dari kolom-kolom seperti nama lagu, artis, album, serta genre dan subgenre playlist ke dalam satu kolom baru bernama 'text_features'. Proses ini dimulai dengan mengidentifikasi kolom-kolom tekstual yang benar-benar ada dalam DataFrame, memastikan datanya bertipe string dan mengisi nilai yang hilang dengan string kosong untuk mencegah error, lalu menggabungkan teks dari kolom-kolom yang sudah disiapkan tersebut untuk setiap lagu menjadi satu string panjang di kolom 'text_features', yang hasilnya sangat penting sebagai representasi konten tekstual setiap item dan siap digunakan untuk ekstraksi fitur teks lebih lanjut seperti TF-IDF dalam sistem rekomendasi berbasis konten."""

# Menggunakan TF-IDF Vectorizer untuk teks
print("Membuat vektor TF-IDF untuk fitur tekstual")
tfidf = TfidfVectorizer(stop_words='english', max_features=10000)
if not df['text_features'].str.strip().empty:
    tfidf_matrix = tfidf.fit_transform(df['text_features'])
    print(f"Dimensi matriks TF-IDF: {tfidf_matrix.shape}")
else:
     print("Peringatan: Fitur tekstual gabungan kosong. TF-IDF matrix tidak dibuat.")
     tfidf_matrix = np.zeros((len(df), 0))
     print(f"Dimensi matriks TF-IDF (kosong): {tfidf_matrix.shape}")

"""Blok kode ini bertanggung jawab untuk mengubah fitur tekstual gabungan dari kolom 'text_features' menjadi representasi numerik menggunakan metode TF-IDF (Term Frequency-Inverse Document Frequency). Ini dilakukan dengan menginisialisasi TfidfVectorizer dari scikit-learn yang dikonfigurasi untuk mengabaikan kata-kata umum dalam bahasa Inggris (stopwords) dan membatasi jumlah fitur (kata unik) hingga max_features tertentu (dalam contoh ini 10000), kemudian memproses teks dari setiap lagu untuk menghasilkan matriks tfidf_matrix. Matriks sparse ini secara efisien merepresentasikan pentingnya setiap kata dalam konteks setiap lagu dan seluruh dataset, menjadikannya komponen penting dari vektor konten yang siap untuk perhitungan kemiripan, dengan tambahan pengecekan untuk menangani kasus jika kolom teks gabungan ternyata kosong."""

# Memilih dan Menskalakan Fitur Numerik (Fitur Audio & Popularitas)
numeric_cols_exist = df.select_dtypes(include=np.number).columns.tolist()
numeric_data = df[numeric_cols_exist]

"""Blok kode ini bertujuan untuk secara otomatis mengidentifikasi dan mengisolasi semua fitur-fitur yang memiliki tipe data numerik (yang mencakup fitur audio, popularitas, dll.) dari DataFrame utama df. Ini dilakukan dengan menggunakan metode df.select_dtypes(include=np.number) yang secara efisien memilih kolom-kolom berbasis angka, menyimpan nama-nama kolom yang ditemukan dalam daftar numeric_cols_exist, dan kemudian membuat sebuah DataFrame baru bernama numeric_data yang hanya berisi data dari kolom-kolom numerik terpilih tersebut, menjadikannya siap untuk langkah pemrosesan selanjutnya seperti penskalaan yang krusial dalam pembentukan vektor fitur konten untuk perhitungan kemiripan."""

# Menskalakan fitur numerik
scaler = StandardScaler()
scaled_numeric_features = scaler.fit_transform(numeric_data)
print("Fitur numerik berhasil diskalakan.")

"""Blok kode ini menjalankan proses skalasi standar pada fitur-fitur numerik yang telah diisolasi (numeric_data) menggunakan StandardScaler dari scikit-learn."""

# Menggabungkan Fitur Tekstual (TF-IDF) dan Numerik (Scaled)
print("Menggabungkan fitur tekstual dan numerik")
if tfidf_matrix.shape[0] == scaled_numeric_features.shape[0]:
     combined_features = hstack([tfidf_matrix, scaled_numeric_features])
     print(f"Dimensi matriks fitur gabungan: {combined_features.shape}")
     print("Fitur gabungan berhasil dibuat.")
else:
     print("ERROR: Jumlah baris matriks tekstual dan numerik tidak cocok! Tidak dapat menggabungkan fitur.")
     combined_features = None # Set None jika gagal digabung

"""Kode ini secara singkat menggabungkan representasi fitur tekstual TF-IDF (tfidf_matrix) dengan fitur numerik yang sudah diskalakan (scaled_numeric_features) menggunakan scipy.sparse.hstack, menumpuknya secara horizontal untuk membentuk vektor fitur gabungan tunggal per lagu bernama combined_features, setelah terlebih dahulu memastikan bahwa kedua matriks memiliki jumlah baris (jumlah lagu) yang sama, yang mana hasil gabungan ini merupakan representasi konten akhir setiap lagu yang akan digunakan untuk menghitung kemiripan antar item."""

# Simpan ID lagu dan mapping index untuk memudahkan lookup nanti
print("\nPembuatan ID Internal & Mapping")
id_col = None
if 'track_id' in df.columns and df['track_id'].notna().all():
    id_col = 'track_id'
    print("Menggunakan 'track_id' sebagai basis ID lagu.")
elif 'id' in df.columns and df['id'].notna().all():
     id_col = 'id'
     print("Menggunakan 'id' sebagai basis ID lagu (karena 'track_id' tidak tersedia/lengkap).")
else:
    df['generated_id'] = df.index.astype(str)
    id_col = 'generated_id'
    print("Peringatan: Tidak ada kolom ID unik yang jelas. Menggunakan index DataFrame sebagai basis ID lagu ('generated_id').")

"""Kode ini berfungsi untuk secara otomatis memilih atau membuat kolom identifikasi unik (ID) untuk setiap lagu dalam DataFrame, yang krusial untuk menghubungkan hasil perhitungan kemiripan (berdasarkan index numerik) kembali ke informasi lagu yang relevan. Proses ini secara berurutan memeriksa apakah kolom 'track_id' atau 'id' tersedia dan lengkap untuk dijadikan basis ID; jika tidak ada yang cocok, akan membuat kolom ID baru 'generated_id' berdasarkan index DataFrame; pada akhirnya, nama kolom ID yang dipilih atau dibuat disimpan dalam variabel id_col, memastikan setiap lagu memiliki pengenal yang handal untuk keperluan mapping dan lookup rekomendasi."""

# Membuat ID internal unik dan hashable
df['song_id_internal'] = df.index.astype(str) + "_" + df[id_col].astype(str)
song_ids = df['song_id_internal'].tolist()

"""Kode ini secara membuat ID internal unik per lagu dengan menggabungkan index DataFrame dan ID basis yang dipilih (id_col) menjadi kolom baru 'song_id_internal', lalu mengubah kolom ini menjadi daftar song_ids, memastikan setiap lagu memiliki pengenal tunggal yang pasti unik dan siap digunakan untuk pembuatan mapping index ke fitur gabungan."""

# Membuat mapping dari ID lagu ke index dalam matriks fitur
id_to_index = {song_id: index for index, song_id in enumerate(song_ids)}
index_to_id = {index: song_id for index, song_id in enumerate(song_ids)}
print("Pembuatan ID internal dan mapping selesai.")

"""Kode ini menyelesaikan tahap persiapan data dengan membuat mapping antara ID internal unik setiap lagu (song_ids) dan index numerik (posisi) mereka dalam matriks fitur gabungan serta matriks kemiripan. Dua kamus, id_to_index yang memetakan ID ke index dan index_to_id yang memetakan index kembali ke ID lagu, dibuat menggunakan list song_ids. Mappings ini sangat penting karena matriks-matriks tersebut diakses menggunakan index numerik, sehingga mapping ini menjembatani ID lagu yang mudah dikenali dengan lokasi data yang sebenarnya, memungkinkan sistem rekomendasi untuk mencari dan mengidentifikasi lagu dengan efisien.

## Modelling
"""

similarity_matrix = None # Inisialisasi

if combined_features is not None and combined_features.shape[1] > 0:
    print("Menghitung Cosine Similarity antar lagu")
    try:
        similarity_matrix = cosine_similarity(combined_features)
        print(f"Dimensi matriks kemiripan: {similarity_matrix.shape}")
        print("Matriks kemiripan berhasil dihitung.")
    except Exception as e:
        print(f"ERROR saat menghitung matriks kemiripan: {e}")
        print("Tidak dapat melanjutkan ke tahap rekomendasi.")
else:
    print("Tidak dapat menghitung matriks kemiripan karena fitur gabungan tidak dibuat atau kosong.")

"""Model ini menggunakan pendekatan Content-Based. Inti dari pemodelan Content-based, blok kode ini menghitung matriks kemiripan antar lagu menggunakan cosine_similarity dari scikit-learn pada fitur gabungan (combined_features) yang telah disiapkan, menghasilkan similarity_matrix yang akan dipakai untuk mencari rekomendasi, setelah terlebih dahulu memeriksa apakah fitur gabungan tersebut valid."""

# Fungsi Rekomendasi
def get_content_based_recommendations(song_id, similarity_matrix, id_to_index, index_to_id, df, num_recommendations=10):
    """
    Memberikan rekomendasi lagu berdasarkan kemiripan konten.

    Args:
        song_id (str/int): ID dari lagu yang menjadi dasar rekomendasi (dari kolom 'song_id_internal').
        similarity_matrix (np.array or sparse matrix): Matriks kemiripan antar item.
        id_to_index (dict): Mapping dari ID lagu ke index baris/kolom di matriks kemiripan.
        index_to_id (dict): Mapping dari index baris/kolom di matriks kemiripan ke ID lagu.
        df (pd.DataFrame): DataFrame asli berisi informasi lagu (termasuk 'song_id_internal').
        num_recommendations (int): Jumlah rekomendasi yang diinginkan.

    Returns:
        pd.DataFrame: DataFrame berisi rekomendasi lagu (kecuali lagu input itu sendiri).
                      Mengandung kolom 'song_id_internal', 'track_name', 'track_artist',
                      'playlist_genre', 'playlist_subgenre', 'Similarity_Score'.
                      Mengembalikan DataFrame kosong jika ID lagu tidak ditemukan atau similarity matrix kosong.
    """
    if similarity_matrix is None:
        print("Error: Similarity matrix belum dibuat.")
        return pd.DataFrame(columns=['song_id_internal', 'track_name', 'track_artist', 'playlist_genre', 'playlist_subgenre', 'Similarity_Score'])

    if song_id not in id_to_index:
        print(f"Error: ID lagu '{song_id}' tidak ditemukan dalam mapping ID ke index.")
        return pd.DataFrame(columns=['song_id_internal', 'track_name', 'track_artist', 'playlist_genre', 'playlist_subgenre', 'Similarity_Score'])

    idx = id_to_index[song_id]
    similarity_scores = similarity_matrix[idx].flatten()

    song_scores = list(enumerate(similarity_scores))
    song_scores = sorted(song_scores, key=lambda x: x[1], reverse=True)[1 : num_recommendations + 1]

    recommended_indices = [i[0] for i in song_scores]
    recommendation_scores = [i[1] for i in song_scores]

    recommended_song_ids = [index_to_id[i] for i in recommended_indices]

    # Mengambil informasi lagu yang direkomendasikan dari DataFrame asli
    if 'song_id_internal' in df.columns:
        recommended_songs_info = df[df['song_id_internal'].isin(recommended_song_ids)].copy()
    else:
         print("Peringatan: Kolom 'song_id_internal' tidak ditemukan di DataFrame asli saat mengambil info rekomendasi.")
         return pd.DataFrame(columns=['song_id_internal', 'track_name', 'track_artist', 'playlist_genre', 'playlist_subgenre', 'Similarity_Score'])

    scores_df = pd.DataFrame({'song_id_internal': recommended_song_ids, 'Similarity_Score': recommendation_scores})

    recommended_songs_info = pd.merge(
        recommended_songs_info,
        scores_df,
        on='song_id_internal',
        how='left'
    ).sort_values(by='Similarity_Score', ascending=False)

    output_cols = ['song_id_internal', 'track_name', 'track_artist', 'playlist_genre', 'playlist_subgenre', 'Similarity_Score']
    output_cols_exist = [col for col in output_cols if col in recommended_songs_info.columns]

    return recommended_songs_info[output_cols_exist]

"""Fungsi get_content_based_recommendations bertindak sebagai mesin rekomendasi utama: fungsi ini menerima ID lagu input, menggunakan matriks kemiripan (similarity_matrix) dan mapping yang relevan untuk menemukan lagu-lagu yang paling mirip berdasarkan konten, dan mengembalikan daftar Top-N lagu rekomendasi beserta skor kemiripannya dalam bentuk DataFrame yang siap disajikan.

## Evaluation
"""

if similarity_matrix is not None and not df.empty:
    print("Melakukan demonstrasi sistem rekomendasi")

    example_indices_raw = [0, len(df) // 4, len(df) // 2, len(df) * 3 // 4, len(df) - 1]
    example_song_indices = [idx for idx in example_indices_raw if 0 <= idx < len(df)]
    example_song_indices = list(set(example_song_indices))
    example_song_indices.sort()

    print(f"Memilih {len(example_song_indices)} lagu contoh untuk demonstrasi:")

    info_cols_exist = ['track_name', 'track_artist', 'playlist_genre', 'playlist_subgenre']
    info_cols_exist = [col for col in info_cols_exist if col in df.columns]
    audio_feature_display_cols = ['danceability', 'energy', 'tempo', 'loudness']
    audio_feature_display_cols_exist = [col for col in audio_feature_display_cols if col in df.columns]


    for idx in example_song_indices:
        example_song_id = df.iloc[idx]['song_id_internal']
        original_song_info = df.iloc[idx]

        print(f"\n--- Rekomendasi untuk Lagu Input (Index: {idx}) ---")
        print(f"ID Internal: {example_song_id}")

        for col in info_cols_exist:
            print(f"{col.replace('_', ' ').title()}: '{original_song_info.get(col, 'N/A')}'")

        if audio_feature_display_cols_exist:
             audio_info_str = ", ".join([f"{col.replace('_', ' ').title()}={original_song_info.get(col, np.nan):.2f}" for col in audio_feature_display_cols_exist])
             print(f"Fitur Audio (contoh): {audio_info_str}")

        recommendations = get_content_based_recommendations(example_song_id, similarity_matrix, id_to_index, index_to_id, df, num_recommendations=5)

        print("\nRekomendasi (Top 5):")
        if not recommendations.empty:
            print(recommendations.to_string())

        else:
            print("Tidak ada rekomendasi ditemukan untuk lagu ini.")

else:
    print("Tidak dapat melakukan evaluasi karena matriks kemiripan tidak berhasil dibuat atau dataset kosong.")

"""Evaluasi sistem rekomendasi ini dirancang untuk mengukur seberapa efektif model Content-based Filtering dalam merekomendasikan lagu-lagu yang relevan. Mengingat ketiadaan data interaksi pengguna eksplisit, proyek ini menggunakan evaluasi kualitatif berbasis konten. ami memilih beberapa lagu contoh dari dataset, yang merepresentasikan berbagai genre dan karakteristik audio. Untuk setiap lagu contoh, sistem rekomendasi dijalankan untuk menghasilkan daftar Top-N lagu yang paling mirip. Hasil rekomendasi ini kemudian dianalisis secara deskriptif. Analisis ini melibatkan pemeriksaan kesamaan pada metadata tekstual (seperti genre, subgenre, artis, dan nama lagu) serta fitur audio (seperti danceability, energy, tempo, dan loudness) antara lagu input dan lagu-lagu yang direkomendasikan. Selain itu, nilai Similarity Score (Cosine Similarity) yang tinggi pada rekomendasi menjadi indikator kuat kemiripan konten yang diukur oleh model. Metrik ini bertujuan untuk memahami mengapa rekomendasi tersebut relevan dari perspektif konten, dan secara langsung selaras dengan tujuan proyek untuk "Menghasilkan Rekomendasi yang Relevan" dan "Melakukan Evaluasi Kualitatif".

Hasil evaluasi kualitatif berbasis konten sebagai contoh, ketika lagu input 'Tranquillo' oleh Escix V (Genre: 'wellness', Subgenre: 'yoga', dengan fitur audio seperti Danceability 0.15, Energy 0.01, Loudness -37.56) diberikan kepada sistem, rekomendasi Top 5 yang dihasilkan menunjukkan relevansi yang kuat seperti pada output sel di atas. Analisis menunjukkan bahwa rekomendasi didominasi oleh lagu-lagu dari genre 'wellness' dan 'ambient' dengan subgenre terkait seperti 'yoga' dan 'chill'. Ini secara langsung mencerminkan genre dan subgenre dari lagu input, membuktikan kemampuan sistem dalam menangkap kemiripan berdasarkan metadata tekstual/kategorikal. Selain itu, skor kemiripan (Similarity Score) yang sangat tinggi (0.925 hingga 0.979) mengindikasikan bahwa model menganggap lagu-lagu ini sangat dekat dengan lagu input di ruang fitur gabungan, termasuk fitur audio yang diskalakan. Hal ini menunjukkan sistem berhasil menemukan lagu-lagu dengan karakteristik "rasa" atau suara yang mirip.
"""

